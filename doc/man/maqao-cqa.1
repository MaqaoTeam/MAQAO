.\" File generated using by MAQAO.
.TH MAQAO-CQA "1" "2018/09/13" "MAQAO-CQA 2.5.9" "User Commands"
.SH NAME
maqao-cqa \- manual page for maqao cqa module.
.SH SYNOPSIS
maqao cqa <binary> [fct-loops=<functions> | fct-body=<functions> | loop=<loops> | path=<block IDs>] [...]
.SH DESCRIPTION
This module analyzes loops, paths or function bodies. It can analyze all innermost loops in a given function or individual loops using the ID returned by other maqao modules (lprof, analyze).
.SH OPTIONS
.TP
\fB\-fl\fR, \fB\-\-fct-loops\fR\=<functions>
Select functions in which innermost loops will be analyzed: foo or "foo, bar". Names are interpreted as Lua patterns/regexps: - for exact match, use "^foo$" instead of foo - to match all functions (i.e analyze all innermost loops in the binary) use ".*"
.TP
\fB\-f\fR, \fB\-\-fct-body\fR\=<functions>
Select functions to analyze: foo or "foo, bar". Names are interpreted  as Lua patterns/regexps: for exact match, use "^foo$" instead of foo.
.TP
\fB\-l\fR, \fB\-\-loop\fR\=<loops>
Select loops (list of loop IDs) to analyze: 17 or "17, 19".
.TP
\fB\-conf\fR, \fB\-\-confidence-levels\fR\=<confidence levels>
For text output format, select confidence levels for displayed reports: gain, potential, hint and expert. Default: gain + potential. To select all: conf=all.
.TP
\fB\-of\fR, \fB\-\-output-format\fR\=<output format>
Select output format: txt (default), html or csv.
.TP
\fB\-op\fR, \fB\-\-output-path\fR\=<output path (html) / file (csv)>
Select output path (html) or file (csv). Default values: cqa_html (html), loops.csv (csv when analyzing loops) and foo.csv (csv when analyzing the foo function).
.TP
\fB\-opr\fR, \fB\-\-opt-report\fR\=<string>
Path to optimization reports generated by Intel/GNU compilers
.SH "    ADVANCED OPTIONS"
.TP
\fB\-p\fR, \fB\-\-path\fR\=<path>
Select path (list of block IDs) to analyze.
.TP
\fB\-ivo\fR, \fB\-\-if-vectorized-options\fR\=<string>
Options for vectorization projection, that will affect "if vectorized" cycles and metrics. Available: force_sse, int_novec 
.TP
\fB\-im\fR, \fB\-\-instructions-modifier\fR\=<string>
Modify instructions before loop analysis. Available: - FULLY_VEC: non fully vectorized (scalar or vectorized on partial vector length) vectorizable instructions are replaced with their fully vectorized equivalent - COMPUTE_VEC: non fully vectorized (scalar or vectorized on partial vector length) vectorizable compute (no memory) instructions are replaced with their fully vectorized equivalent - MEM_VEC: non fully vectorized (scalar or vectorized on partial vector length) vectorizable memory instructions are replaced with their fully vectorized equivalent - VECTOR_ISET: only vector (belonging to a vector instruction set) and loop control instructions are considered - FP: only FP and loop control instructions are considered - FP_ARITH: only FP arithmetical and loop control instructions are considered. FP arithmetical instructions with a source memory operand are replaced with their register equivalent.
.TP
\fB\-imo\fR, \fB\-\-instructions-modifier-options\fR\=<string>
Options to refine instructions modifier behavior. Available: vector_aligned, vector_unaligned, force_sse, int_novec, force_vec, no_gather 
.TP
\fB\-dist\fR, \fB\-\-loop-distance\fR\=<positive integer>
Override LOOP_MERGE_DISTANCE default value (2). Prevents loop unrolling detector from assuming close source lines correspond to the same loop.
.TP
\fB\-max_paths\fR, \fB\-\-max-paths-nb\fR\=<positive integer>
Override MAX_NB_PATHS default value (8), allow to analyze loops with more paths.
.TP
\fB\-igp\fR, \fB\-\-ignore-paths\fR
Ignore paths: assume all blocks as belonging to a unique path. Be aware that such a path has no real existence !
.TP
\fB\-fc\fR, \fB\-\-follow-calls\fR\="append"|"inline"
Follow calls by appending/inlining corresponding instructions
.TP
\fB\-sb\fR, \fB\-\-select-blocks\fR\=<string>
Name of a Lua function to use to select loop blocks. Such a function must be defined in loop_blocks_selection_functions.lua (located in current directory) and return a list of blocks from a loop. Example: function foo (loop)    local blocks = {}    for block in loop:blocks() do       if (not block:is_loop_exit()) then          table.insert (blocks, block)       end    end    return blocks end 
.TP
\fB\-vu\fR, \fB\-\-virtual-unrolling\fR\=<positive integer>
Virtual unrolling factor. Inner loops body will be duplicated accordingly. Implies "allow-non-innermost"
.TP
\fB\-um\fR, \fB\-\-uarch-model\fR\=<string>
User micro-architecture model. Path to a Lua file defining a table named __user_uarch_consts containing micro-architectural constants that will be used instead of MAQAO default ones. Target micro-architecture is not changed but only its details !
.TP
\fB\-ml\fR, \fB\-\-memory-level\fR\=<string>
Memory level to use when reading data into the file passed with the memory-level-cycles-filepath option
.TP
\fB\-mlf\fR, \fB\-\-memory-level-filepath\fR\=<string>
Path to a Lua file defining a table containing cycles to use for L2/L3/RAM projections
.TP
\fB\-ieb\fR, \fB\-\-insn-ext-bypass\fR\=<string>
Path to a table used to override instructions extensions.
.TP
\fB\-ud\fR, \fB\-\-user-data\fR\=<string>
Path to a Lua file defining a table containing user data
.TP
\fB\-lm\fR, \fB\-\-list-metrics\fR
Generate JSON file listing available metrics and exit (no binary analysis)
.TP
\fB\-uo\fR, \fB\-\-ufs-opts\fR\="opt1=val1,opt2=val2..."
Options driving UFS (Uops Flow Simulator). Available:  - enable=(yes)|no  - max_lat_only=yes|(no) (for variable latency instructions like divide and square root, ignore minimum latency)  - mode=(forward)|dump|bypass  - ooo_filepath=<path to ooo file> (in dump/bypass modes)  - FP_load_latency=<positive number> (6 by default)  - load_latency=<positive number> (4 by default)  - store_latency=<positive number> (4 by default)  - groupN_latency=<positive number>  - X_size=<positive number> (overrides size for X = ROB, RS, LB, LM, SB, PRF, PRF_INT, PRF_FLOAT)  - max_iters=<positive number> (100 by default): maximum number of retired iterations  - max_cycles=<positive_number> (5000 by default): maximum number of simulated cycles  - l1dr_per_iteration=<positive number>  - l1dr_granularity=(iteration)|cacheline: granularity when computing LFB contribution of each instruction. For cacheline granularity, use unroll option accordingly  - ignore_cacheline_tags=yes|(no): in the bypass mode, ignores cacheline tags (cache_line=<ID> in the 'special' field)  - ignore_cache_level=yes|(no): in the bypass mode, ignores cache level (cache_level=1/2... in the 'special' field)  - unroll=<positive_number> (1 by default): process iterations N by N, required for cacheline granularity  - save_intermed=yes|(no) (save results after each new retired iteration)  - nb_active_threads=<positive number> (number of active threads per core in SMT context)  - verbose=yes|(no) 
.TP
\fB\-sr\fR, \fB\-\-enable-stride-report\fR
[EXPERIMENTAL] Add data access stride analysis report in hint level
.SH "    MAN PAGE"
.TP
\fB\-\-generate-man\fR
Generate the man page of the module based on the module help in the current directory. The generated file is called maqao-<module>.1. Once the man page is generated, the program exits.
.TP
\fB\-\-output\fR\=<path>
Specify the path where the man page is generated.
.TP
\fB\-\-generate-wiki\fR
Generate the wiki page of the module based on the module help on the standart output. Once the man page is generated, the program exits.
.SH "    OPTIONAL FLAGS COMMON TO ALL MODULES"
.TP
\fB\-\-disable-debug\fR
Disable debug data loading. WARNING, this option may alter the tool's accuracy.
.TP
\fB\-\-compiler\fR\=<compiler>
Select the compiler used to create the binary. Available values are: 
GNU, Intel.

.TP
\fB\-\-language\fR\=<language>
Select the source language. Available values are: 
c, c++, fortran.

.TP
\fB\-\-lcore-flow-all\fR
Analyze all instructions returned by MADRAS. Default behaviour is to analyze instructions from sections .text, .init, .fini and .madras.code. 
.TP
\fB\-\-uarch\fR\=<uarch>
Select the micro architecture used for analysis. Available values are: 
.TP 20 
\fB       For arm64 architecture:\fR 
CORTEX_A57 ()
.
.SH ""
.TP
\fB\-\-proc\fR\=<proc>
Select the processor model used for analysis. maqao --list-procs to display supported processors
.TP
\fB\-ifr\fR, \fB\-\-interleaved-functions-recognition\fR\=<mode>
Select the mode of interleaved functions recognition. Available values are: 
.TP 20 
\fB       off\fR 
Functions are not extracted from connected components.
.TP 20 
\fB       debug_based\fR  (default)
Functions are extracted from connected components matching with debug data.
.TP 20 
\fB       all\fR 
All connected components are extracted into new functions whether they correspond to the debug information or not.
.
.SH ""
.TP
\fB\-dbg\fR, \fB\-\-debug\fR[\=<level>]
Enable debug messages. <level> can be used to specify the level of debug messages to display. Available values are: 
0, 1 (default).

.TP
\fB\-\-\fR
Specify binary parameters for dynamic analysis. Next options are ignored by MAQAO.
.TP
\fB\-h\fR, \fB\-\-help\fR
Print the current help.
.TP
\fB\-v\fR, \fB\-\-version\fR
Print the current version.
.SH AUTHOR
Written by The MAQAO team.
.SH "REPORTING BUGS"
Report bugs to <support@maqao.org>.
.SH COPYRIGHT
MAQAO (C), 2004-2018 Universite de Versailles Saint-Quentin-en-Yvelines (UVSQ), 
is distributed under the GNU Lesser General Public License (GNU LGPL). MAQAO is 
free software; you can use it under the terms of the GNU Lesser General 
Public License as published by the Free Software Foundation; either version 2.1 
of the License, or (at your option) any later version. This software is distributed 
in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU Lesser General Public License for more details.

The full legal text of the GNU Lesser General Public License (GNU LGPL) is available
at http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
.SH "SEE ALSO"
maqao(1), maqao-madras(1), maqao-disass(1), maqao-lprof(1), maqao-analyze(1)
